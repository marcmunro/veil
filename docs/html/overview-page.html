<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Veil: Overview: a quick introduction to Veil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Veil
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('overview-page.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Overview: a quick introduction to Veil </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Overview-section"></a>
Introduction</h1>
<p>The section introduces a number of key concepts, and shows the basic components of a Veil-protected system:</p><ul>
<li><a class="el" href="overview-page.html#over-views">Secured Views and Access Functions</a></li>
<li><a class="el" href="overview-page.html#over-connections">The Connected User and Connection Functions</a></li>
<li><a class="el" href="overview-page.html#over-privs">Privileges</a></li>
<li><a class="el" href="overview-page.html#over-contexts">Security Contexts</a></li>
<li><a class="el" href="overview-page.html#over-funcs2">Access Functions and Security Contexts</a></li>
<li><a class="el" href="overview-page.html#over-roles">Grouping Privileges by Roles</a></li>
</ul>
<h2><a class="anchor" id="over-views"></a>
Secured Views and Access Functions</h2>
<p>Access controls are implemented using secured views and instead-of triggers. Users connect to an account that has access only to the secured views. For a table defined thus: </p><pre class="fragment">create table persons (
    person_id       integer not null,
    person_name     varchar(80) not null
);
</pre><p> The secured view would be defined something like this: </p><pre class="fragment">create view persons(
       person_id, person_name) as
select person_id, person_name
  from persons
 where i_have_personal_priv(10013, person_id);
</pre><p>A query performed on the view will return rows only for those persons where the current user has privilege 10013 (<code>SELECT_PERSONS</code>). We call the function <code>i_have_personal_priv()</code>, an access function. Such functions are user-defined, and are used to determine whether the connected user has a specific privilege in any of a number of security contexts (see <a class="el" href="overview-page.html#over-contexts">Security Contexts</a>). The example above is taken from the Veil demo application (<a class="el" href="Demo.html#demo-sec">The Veil Demo Application</a>) and checks for privilege in the global and personal contexts.</p>
<h2><a class="anchor" id="over-connections"></a>
The Connected User and Connection Functions</h2>
<p>To determine a user's privileges, we have to know who that user is. At the start of each database session the user must be identified, and their privileges must be determined. This is done by calling a connection function, eg: </p><pre class="fragment">select connect_person('Wilma', 'AuthenticationTokenForWilma');
</pre><p> The connection function performs authentication, and stores the user's access privileges in Veil state variables. These variables are then interrogated by the access functions used in the secured views.</p>
<p>Prior to connection, or in the event of the connection failing, the session will have no privileges and will probably be unable to see any data. Like access functions, connection functions are user-defined and may be written in any language supported by PostgreSQL.</p>
<h2><a class="anchor" id="over-privs"></a>
Privileges</h2>
<p>Veil-based systems define access rights in terms of privileges. A privilege is a named thing with a numerical value (actually, the name is kind of optional).</p>
<p>An example will probably help. Here is a definition of a privileges table and a subset of its data: </p><pre class="fragment">create table privileges (
    privilege_id    integer not null,
    privilege_name  varchar(80) not null
);

copy privileges (privilege_id, privilege_name) from stdin;
10001   select_privileges
10002   insert_privileges
10003   update_privileges
10004   delete_privileges
. . .
10013   select_persons
10014   insert_persons
10015   update_persons
10016   delete_persons
10017   select_projects
10018   insert_projects
10019   update_projects
10020   delete_projects
. . .
10100   can_connect
\.</pre><p> Each privilege describes something that a user can do. It is up to the access and connection functions to make use of these privileges; the name of the privilege is only a clue to its intended usage. In the example we might expect that a user that has not been given the <code>can_connect</code> privilege would not be able to authenticate using a connection function but this is entirely dependent on the implementation.</p>
<h2><a class="anchor" id="over-contexts"></a>
Security Contexts</h2>
<p>Users may be assigned privileges in a number of different ways. They may be assigned directly, indirectly through various relationships, or may be inferred by some means. To aid in the discussion and design of a Veil-based security model we introduce the concept of security contexts, and we say that a user has a given set of privileges in a given context. There are three types of security context:</p>
<ul>
<li>Global Context. This refers to privileges that a user has been given globally. If a user has <code>select_persons</code> privilege in the global context, they will be able to select every record in the persons table. Privileges in global context are exactly like database-level privileges: there is no row-level element to them.</li>
<li>Personal Context. This context provides privileges on data that you may be said to own. If you have <code>select_persons</code> privilege in only the personal context, you will only be able to select your own persons record. Assignment of privileges in the personal context is often defined implicitly or globally, for all users, rather than granted explicitly to each user. It is likely that everyone should have the same level of access to their own data so it makes little sense to have to explicitly assign the privileges for each individual user.</li>
<li>Relational Contexts. These are the key to most row-level access controls. Privileges assigned in a relational context are assigned through relationships between the connected user and the data to be accessed. Examples of relational contexts include: assignments to projects, in which a user will gain access to project data only if they have been assigned to the project; and the management hierarchy within a business, in which a manager may have specific access to data about a staff member. Note that determining a user's access rights in a relational context may require extra queries to be performed for each function call. Your design should aim to minimise this. Some applications may require several distinct relational contexts.</li>
</ul>
<h2><a class="anchor" id="over-funcs2"></a>
Access Functions and Security Contexts</h2>
<p>Each access function will operate on privileges for a specific set of contexts. For some tables, access will only be through global context. For others, it may be through global and personal as well as a number of different relational contexts. Here, from the demo application, are a number of view definitions, each using a different access function that checks different contexts. </p><pre class="fragment">create view privileges(
       privilege_id,
       privilege_name) as
select privilege_id,
       privilege_name
from   privileges
where  i_have_global_priv(10001);

. . .

create view persons(
       person_id,
       person_name) as
select person_id,
       person_name
from   persons
where  i_have_personal_priv(10013, person_id);

. . .

create view projects(
       project_id,
       project_name) as
select project_id,
       project_name
from   projects
where  i_have_project_priv(10017, project_id);

. . .

create view assignments (
       project_id,
       person_id,
       role_id) as
select project_id,
       person_id,
       role_id
from   assignments
where  i_have_proj_or_pers_priv(10025, project_id, person_id);
</pre><p>In the <code>privileges</code> view, we only check for privilege in the global context. This is a look-up view, and should be visible to all authenticated users.</p>
<p>The <code>persons</code> view checks for privilege in both the global and personal contexts. It takes an extra parameter identifying the person who owns the record. If that person is the same as the connected user, then privileges in the personal context may be checked. If not, only the global context applies.</p>
<p>The <code>projects</code> view checks global and project contexts. The project context is a relational context. In the demo application, a user gains privileges in the project context through assignments. An assignment is a relationship between a person and a project. Each assignment record has a role. This role describes the set of privileges the assignee (person) has within the project context.</p>
<p>The <code>assignments</code> view checks all three contexts (global, personal and project). An assignment contains data about a person and a project so privileges may be acquired in either of the relational contexts, or globally.</p>
<h2><a class="anchor" id="over-roles"></a>
Grouping Privileges by Roles</h2>
<p>Privileges operate at a very low-level. In a database of 100 tables, there are likely to be 500 to 1,000 privileges in use. Managing users access at the privilege level is, at best, tedious. Instead, we tend to group privileges into roles, and assign only roles to individual users. Roles act as function-level collections of privileges. For example, the role <code>project-readonly</code> might contain all of the <code>select_xxx</code> privileges required to read all project data.</p>
<p>A further refinement allows roles to be collections of sub-roles. Defining suitable roles for a system is left as an exercise for the reader.</p>
<p>Next: <a class="el" href="API-page.html">The Veil API</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Veil</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
